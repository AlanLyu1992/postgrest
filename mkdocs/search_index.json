{
    "docs": [
        {
            "location": "/", 
            "text": "Introduction\n\n\nPostgREST is a standalone web server that turns your database directly into a RESTful API. The structural constraints and permissions in the database determine the API endpoints and operations.\n\n\nThis guide explains how to install the software and provides practical examples of its use. You'll learn how to build a fast, versioned, secure API and how to deploy it to production.\n\n\nThe project has a friendly and growing community. Here are some ways to get help or get involved:\n\n\n\n\nThe project \nchat room\n\n\nReport or search \nissues\n\n\n\n\nMotivation\n\n\nUsing PostgREST is an alternative to manual CRUD programming. Custom API servers suffer problems. Writing business logic often duplicates, ignores or hobbles database structure. Object-relational mapping is a leaky abstraction leading to slow imperative code. The PostgREST philosophy establishes a single declarative source of truth: the data itself.\n\n\nDeclarative Programming\n\n\nIt's easier to ask Postgres to join data for you and let its query planner figure out the details than to loop through rows yourself. It's easier to assign permissions to db objects than to add guards in controllers. (This is especially true for cascading permissions in data dependencies.) It's easier set constraints than to litter code with sanity checks.\n\n\nLeakproof Abstraction\n\n\nThere is no ORM involved. Creating new views happens in SQL with known performance implications. A database administrator can now create an API from scratch with no custom programming. \n\n\nEmbracing the Relational Model\n\n\nIn 1970 E. F. Codd criticized the then-dominant hierarchical model of databases in his article \nA Relational Model of Data for Large Shared Data Banks\n. Reading the article reveals a striking similarity between hierarchical databases and nested http routes. With PostgREST we attempt to use flexible filtering and embedding rather than nested routes.\n\n\nOne Thing Well\n\n\nPostgREST has a focused scope. It works well with other tools like Nginx. This forces you to cleanly separate the data-centric CRUD operations from other concerns. Use a collection of sharp tools rather than building a big ball of mud.\n\n\nShared Improvements\n\n\nAs with any open source project, we all gain from features and fixes in the tool. It's more beneficial than improvements locked inextricably within custom codebases.\n\n\nMyths\n\n\nYou have to make tons of stored procs and triggers\n\n\nModern PostgreSQL features like auto-updatable views and computed columns make this mostly unnecessary. Triggers do play a part, but generally not for irksome boilerplate. When they are required triggers are preferable to ad-hoc app code anyway, since the former work reliably for any codepath.\n\n\nExposing the database destroys encapsulation\n\n\nPostgREST does versioning through database schemas. This allows you to expose tables and views without making the app brittle. Underlying tables can be superseded and hidden behind public facing views. The chapter about versioning shows how to do this.\n\n\nConventions\n\n\nThis guide contains highlighted notes and tangential information interspersed with the text.\n\n\n\n    \nDesign Consideration\n\n\n    \nContains history which informed the current design. Sometimes it discusses unavoidable tradeoffs or a point of theory.\n\n\n\n\n\n\n    \nInvitation to Contribute\n\n\n    \nPoints out things we know we want to add or improve. They might give you ideas for ways to contribute to the project.\n\n\n\n\n\n\n    \nDeprecation Warning\n\n\n    \nAlerts you to features which will be removed in the next major (breaking) release.", 
            "title": "Home"
        }, 
        {
            "location": "/#introduction", 
            "text": "PostgREST is a standalone web server that turns your database directly into a RESTful API. The structural constraints and permissions in the database determine the API endpoints and operations.  This guide explains how to install the software and provides practical examples of its use. You'll learn how to build a fast, versioned, secure API and how to deploy it to production.  The project has a friendly and growing community. Here are some ways to get help or get involved:   The project  chat room  Report or search  issues   Motivation  Using PostgREST is an alternative to manual CRUD programming. Custom API servers suffer problems. Writing business logic often duplicates, ignores or hobbles database structure. Object-relational mapping is a leaky abstraction leading to slow imperative code. The PostgREST philosophy establishes a single declarative source of truth: the data itself.  Declarative Programming  It's easier to ask Postgres to join data for you and let its query planner figure out the details than to loop through rows yourself. It's easier to assign permissions to db objects than to add guards in controllers. (This is especially true for cascading permissions in data dependencies.) It's easier set constraints than to litter code with sanity checks.  Leakproof Abstraction  There is no ORM involved. Creating new views happens in SQL with known performance implications. A database administrator can now create an API from scratch with no custom programming.   Embracing the Relational Model  In 1970 E. F. Codd criticized the then-dominant hierarchical model of databases in his article  A Relational Model of Data for Large Shared Data Banks . Reading the article reveals a striking similarity between hierarchical databases and nested http routes. With PostgREST we attempt to use flexible filtering and embedding rather than nested routes.  One Thing Well  PostgREST has a focused scope. It works well with other tools like Nginx. This forces you to cleanly separate the data-centric CRUD operations from other concerns. Use a collection of sharp tools rather than building a big ball of mud.  Shared Improvements  As with any open source project, we all gain from features and fixes in the tool. It's more beneficial than improvements locked inextricably within custom codebases.  Myths  You have to make tons of stored procs and triggers  Modern PostgreSQL features like auto-updatable views and computed columns make this mostly unnecessary. Triggers do play a part, but generally not for irksome boilerplate. When they are required triggers are preferable to ad-hoc app code anyway, since the former work reliably for any codepath.  Exposing the database destroys encapsulation  PostgREST does versioning through database schemas. This allows you to expose tables and views without making the app brittle. Underlying tables can be superseded and hidden behind public facing views. The chapter about versioning shows how to do this.  Conventions  This guide contains highlighted notes and tangential information interspersed with the text.  \n     Design Consideration \n\n     Contains history which informed the current design. Sometimes it discusses unavoidable tradeoffs or a point of theory.   \n     Invitation to Contribute \n\n     Points out things we know we want to add or improve. They might give you ideas for ways to contribute to the project.   \n     Deprecation Warning \n\n     Alerts you to features which will be removed in the next major (breaking) release.", 
            "title": "Introduction"
        }, 
        {
            "location": "/install/server/", 
            "text": "Installation\n\n\nInstalling from Pre-Built Release\n\n\nThe \nrelease page\n has precompiled binaries for Mac OS X and 64-bit Ubuntu. Next extract the tarball and run the binary inside with no arguments to see usage instructions:\n\n\n# Untar the release (available at https://github.com/begriffs/postgrest/releases/latest)\n\n$ tar zxf postgrest-0.2.11.1-osx.tar.xz\n\n# Try running it\n$ ./postgrest-0.2.11.1\n\n# You should see a usage help message\n\n\n\n\n\n    \nDeprecation Warning\n\n\n    \nThe filename inside the tarball currently includes a version\n    number, but this will be removed in the next version for cleaner\n    post-extraction scripting.\n\n\n\n\n\n\n    \nInvitation to Contribute\n\n\n    \nI currently build the binaries manually for each version. We need to set up an automated build matrix for various architectures. It should support 32- and 64-bit versions of\n\n    \nScientific Linux 6\nCentOS\nRHEL 6\n\n\n    Also it would be good to create packages for Homebrew, and apt.\n\n\n\n\n\nWe'll learn the meaning of the command line flags later, but here is a minimal example of running the app. It does all operations as user \npostgres\n, including for unauthenticated requests.\n\n\n$ ./postgrest-0.2.11.1 -d dbname -U postgres --a postgres --v1schema public\n\n\n\n\nBuilding from Source\n\n\nWhen a prebuilt binary does not exist for your system you can build the project from source. You'll also need to do this if you want to help with development. \nStack\n makes it easy. It will install any necessary Haskell dependencies on your system.\n\n\n\n\nInstall Stack\n for your platform\n\n\nBuild the project\n\n\n\n\ngit clone https://github.com/begriffs/postgrest.git\ncd postgrest\nstack build\n\n\n\n\n\n\nRun the server\n\n\n\n\nstack exec postgrest -- arg1 arg2\n# ... your arguments after the double dashes\n\n\n\n\nIf you want to run the test suite, stack can do that too: \nstack test\n.\n\n\nInstalling PostgreSQL\n\n\nTo use PostgREST you will need an underlying database. You can use something like Amazon \nRDS\n but installing your own locally is cheaper and more convenient for development.\n\n\n\n\nInstructions for OS X\n\n\nInstructions for Ubuntu 14.04", 
            "title": "The Server"
        }, 
        {
            "location": "/install/server/#installation", 
            "text": "Installing from Pre-Built Release  The  release page  has precompiled binaries for Mac OS X and 64-bit Ubuntu. Next extract the tarball and run the binary inside with no arguments to see usage instructions:  # Untar the release (available at https://github.com/begriffs/postgrest/releases/latest)\n\n$ tar zxf postgrest-0.2.11.1-osx.tar.xz\n\n# Try running it\n$ ./postgrest-0.2.11.1\n\n# You should see a usage help message  \n     Deprecation Warning \n\n     The filename inside the tarball currently includes a version\n    number, but this will be removed in the next version for cleaner\n    post-extraction scripting.   \n     Invitation to Contribute \n\n     I currently build the binaries manually for each version. We need to set up an automated build matrix for various architectures. It should support 32- and 64-bit versions of\n\n     Scientific Linux 6 CentOS RHEL 6 \n\n    Also it would be good to create packages for Homebrew, and apt.   We'll learn the meaning of the command line flags later, but here is a minimal example of running the app. It does all operations as user  postgres , including for unauthenticated requests.  $ ./postgrest-0.2.11.1 -d dbname -U postgres --a postgres --v1schema public  Building from Source  When a prebuilt binary does not exist for your system you can build the project from source. You'll also need to do this if you want to help with development.  Stack  makes it easy. It will install any necessary Haskell dependencies on your system.   Install Stack  for your platform  Build the project   git clone https://github.com/begriffs/postgrest.git\ncd postgrest\nstack build   Run the server   stack exec postgrest -- arg1 arg2\n# ... your arguments after the double dashes  If you want to run the test suite, stack can do that too:  stack test .  Installing PostgreSQL  To use PostgREST you will need an underlying database. You can use something like Amazon  RDS  but installing your own locally is cheaper and more convenient for development.   Instructions for OS X  Instructions for Ubuntu 14.04", 
            "title": "Installation"
        }, 
        {
            "location": "/install/ecosystem/", 
            "text": "Ecosystem\n\n\nClient-Side Libraries\n\n\n\n\nmithril.postgrest\n - Mithril plugin to create and authenticate requests\n\n\nlewisjared/postgrest-request\n - node interface to postgrest instances\n\n\nJarvusInnovations/jarvus-postgrest-apikit\n - Sencha framework package for binding models/stores/proxies to PostgREST tables\n\n\n\n\nExtensions\n\n\n\n\nsrid/spas\n - allow file uploads and basic auth\n\n\n\n\nExample Apps\n\n\n\n\ntimwis/ext-postgrest-crud\n - browser-based spreadsheet\n\n\nsrid/chronicle\n - tracking a tree of personal memories\n\n\nbegriffs/postgrest-example\n - how to configure a db for use as an API\n\n\nmarmelab/ng-admin-postgrest\n - automatic database admin panel\n\n\ntyrchen/goodfilm\n - example film api\n\n\n\n\nIn Production\n\n\n\n\nCatarse", 
            "title": "Ecosystem"
        }, 
        {
            "location": "/install/ecosystem/#ecosystem", 
            "text": "Client-Side Libraries   mithril.postgrest  - Mithril plugin to create and authenticate requests  lewisjared/postgrest-request  - node interface to postgrest instances  JarvusInnovations/jarvus-postgrest-apikit  - Sencha framework package for binding models/stores/proxies to PostgREST tables   Extensions   srid/spas  - allow file uploads and basic auth   Example Apps   timwis/ext-postgrest-crud  - browser-based spreadsheet  srid/chronicle  - tracking a tree of personal memories  begriffs/postgrest-example  - how to configure a db for use as an API  marmelab/ng-admin-postgrest  - automatic database admin panel  tyrchen/goodfilm  - example film api   In Production   Catarse", 
            "title": "Ecosystem"
        }, 
        {
            "location": "/api/reading/", 
            "text": "Requesting Information\n\n\nTables and Views\n\n\nStored Procedures\n\n\nFiltering\n\n\nComputed Columns\n\n\nInside JSONB\n\n\nOrdering\n\n\nLimiting and Pagination\n\n\nPagination by Limit-Offset\n\n\nSuppressing Counts\n\n\nEmbedding Foreign Keys\n\n\nResponse Format\n\n\nSingular vs Plural\n\n\nData Schema\n\n\nCORS", 
            "title": "Reading"
        }, 
        {
            "location": "/api/reading/#requesting-information", 
            "text": "Tables and Views  Stored Procedures  Filtering  Computed Columns  Inside JSONB  Ordering  Limiting and Pagination  Pagination by Limit-Offset  Suppressing Counts  Embedding Foreign Keys  Response Format  Singular vs Plural  Data Schema  CORS", 
            "title": "Requesting Information"
        }, 
        {
            "location": "/api/writing/", 
            "text": "Updating Data\n\n\nRecord Creation\n\n\nBulk Insertion\n\n\nUpsertion\n\n\nBulk Updates\n\n\nDeletion\n\n\nProtecting Dangerous Actions", 
            "title": "Writing"
        }, 
        {
            "location": "/api/writing/#updating-data", 
            "text": "Record Creation  Bulk Insertion  Upsertion  Bulk Updates  Deletion  Protecting Dangerous Actions", 
            "title": "Updating Data"
        }, 
        {
            "location": "/admin/security/", 
            "text": "Security\n\n\nSSL\n\n\nDatabase Roles\n\n\nJSON Web Tokens\n\n\nIssuing via sql procedures\n\n\nRow-Level Security\n\n\nSimulated - PostgreSQL \n9.5\n\n\nReal - PostgreSQL \n=9.5\n\n\nBuilding Auth on top of JWT\n\n\nBasic Auth\n\n\nGithub Sign-in", 
            "title": "Security"
        }, 
        {
            "location": "/admin/security/#security", 
            "text": "SSL  Database Roles  JSON Web Tokens  Issuing via sql procedures  Row-Level Security  Simulated - PostgreSQL  9.5  Real - PostgreSQL  =9.5  Building Auth on top of JWT  Basic Auth  Github Sign-in", 
            "title": "Security"
        }, 
        {
            "location": "/admin/versioning/", 
            "text": "API Versioning\n\n\nSchema Search Path\n\n\nChanging a Resource\n\n\nRemoving a Resource\n\n\nAvoiding DB and Client Coupling", 
            "title": "Versioning"
        }, 
        {
            "location": "/admin/versioning/#api-versioning", 
            "text": "Schema Search Path  Changing a Resource  Removing a Resource  Avoiding DB and Client Coupling", 
            "title": "API Versioning"
        }, 
        {
            "location": "/admin/migration/", 
            "text": "Data Migration\n\n\nSqitch\n\n\nTest-Driven Migrations\n\n\nStructural Tests\n\n\nValue Tests with pgTAP", 
            "title": "Migration"
        }, 
        {
            "location": "/admin/migration/#data-migration", 
            "text": "Sqitch  Test-Driven Migrations  Structural Tests  Value Tests with pgTAP", 
            "title": "Data Migration"
        }, 
        {
            "location": "/admin/deployment/", 
            "text": "Deployment\n\n\nHeroku\n\n\nGetting Started\n\n\nUsing Amazon RDS\n\n\nDebian", 
            "title": "Deployment"
        }, 
        {
            "location": "/admin/deployment/#deployment", 
            "text": "Heroku  Getting Started  Using Amazon RDS  Debian", 
            "title": "Deployment"
        }, 
        {
            "location": "/admin/performance/", 
            "text": "Performance\n\n\nBenchmarks\n\n\nCaching\n\n\nQuality of Service\n\n\nTips", 
            "title": "Performance"
        }, 
        {
            "location": "/admin/performance/#performance", 
            "text": "Benchmarks  Caching  Quality of Service  Tips", 
            "title": "Performance"
        }, 
        {
            "location": "/examples/start/", 
            "text": "Getting Started\n\n\nYour First (simple) API\n\n\nLet's start with the simplest thing possible. We will expose some tables directly for reading and writing by anyone.\n\n\nStart by making a database\n\n\ncreatedb demo1\n\n\n\n\nWe'll set it up with a film example (courtesy of \nJonathan Harrington\n). Copy the following into your clipboard:\n\n\nBEGIN;\n\nCREATE TABLE director\n(\n  name text NOT NULL PRIMARY KEY\n);\n\nCREATE TABLE film\n(\n  id serial PRIMARY KEY,\n  title text NOT NULL,\n  year date NOT NULL,\n  director text,\n  rating real NOT NULL DEFAULT 0,\n  language text NOT NULL,\n  CONSTRAINT film_director_fkey FOREIGN KEY (director)\n      REFERENCES director (name) MATCH SIMPLE\n      ON UPDATE CASCADE ON DELETE CASCADE\n);\n\nCREATE TABLE festival\n(\n  name text NOT NULL PRIMARY KEY\n);\n\nCREATE TABLE competition\n(\n  id serial PRIMARY KEY,\n  name text NOT NULL,\n  festival text NOT NULL,\n  year date NOT NULL,\n\n  CONSTRAINT comp_festival_fkey FOREIGN KEY (festival)\n      REFERENCES festival (name) MATCH SIMPLE\n      ON UPDATE CASCADE ON DELETE CASCADE\n);\n\nCREATE TABLE film_nomination\n(\n  id serial PRIMARY KEY,\n  competition integer NOT NULL,\n  film integer NOT NULL,\n  won boolean NOT NULL DEFAULT true,\n\n  CONSTRAINT nomination_competition_fkey FOREIGN KEY (competition)\n     REFERENCES competition (id) MATCH SIMPLE\n     ON UPDATE NO ACTION ON DELETE NO ACTION,\n  CONSTRAINT nomination_film_fkey FOREIGN KEY (film)\n     REFERENCES film (id) MATCH SIMPLE\n     ON UPDATE CASCADE ON DELETE CASCADE\n);\n\nCOMMIT;\n\n\n\n\nApply it to your new database by running\n\n\n# On OS X\npbpaste | psql demo1\n\n# Or Linux\n# xclip -selection clipboard -o | psql demo1\n\n\n\n\nStart the PostgREST server and point it at the new database.\n\n\npostgrest -d demo1 -U postgres -a postgres --v1schema public\n\n\n\n\n\n    \nNote about database users\n\n\n    \nIf you installed PostgreSQL with Homebrew on Mac then the\n    database username may be your own login rather than\n    \npostgres\n.\n\n\n\n\n\nLet's use PostgREST to populate the database. Install a REST client such as \nPostman\n. Now let's insert some data as a bulk post in CSV format:\n\n\nPOST http://localhost:3000/festival\nContent-Type: text/csv\n\nname\nVenice Film Festival\nCannes Film Festival\n\n\n\n\nIn Postman it will look like this\n\n\n\n\nNotice that the post type is \nraw\n and that \nContent-Type: text/csv\n set in the Headers tab. \n\n\nNote that the server returns a multipart response with URL of each created resource.\n\n\nContent-Type: application/json\nLocation: /festival?name=eq.Venice%20Film%20Festival\n\n\n--postgrest_boundary\nContent-Type: application/json\nLocation: /festival?name=eq.Cannes%20Film%20Festival\n\n\n\n\nIf you send a GET request to \n/festival\n it should return\n\n\n[\n  {\n    \nname\n: \nVenice Film Festival\n\n  },\n  {\n    \nname\n: \nCannes Film Festival\n\n  }\n]\n\n\n\n\nNow that you've seen how to do a bulk insert, let's do some more and fully populate the database.\n\n\nPost the following to \n/competition\n:\n\n\nname,festival,year\nGolden Lion,Venice Film Festival,2014-01-01\nPalme d'Or,Cannes Film Festival,2014-01-01\n\n\n\n\nNow \n/director\n:\n\n\nname\nBertrand Bonello\nAtom Egoyan\nDavid Gordon Green\nAndrey Konchalovskiy\nMario Martone\nMike Leigh\nRoy Andersson\nSaverio Costanzo\nAlix Delaporte\nJean-Pierre Dardenne\nXiaoshuai Wang\nKaan M\u00fcjdeci\nTommy Lee Jones\nNuri Bilge Ceylan\nMichel Hazanavicius\nXavier Dolan\nRamin Bahrani\nAlice Rohrwacher\nAndrew Niccol\nRakhshan Bani-Etemad\nDavid Oelhoffen\nBennett Miller\nDavid Cronenberg\nShin'ya Tsukamoto\nJoshua Oppenheimer\nOlivier Assayas\nJean-Luc Godard\nAlejandro Gonz\u00e1lez I\u00f1\u00e1rritu\nBeno\u00eet Jacquot\nFatih Akin\nFrancesco Munzi\nKen Loach\nAbel Ferrara\nXavier Beauvois\nNaomi Kawase\n\n\n\n\nAnd \n/film\n:\n\n\ntitle,year,director,rating,language\nChuang ru zhe,2014-01-01,Xiaoshuai Wang,6.19999981,english\nThe Look of Silence,2014-01-01,Joshua Oppenheimer,8.30000019,Indonesian\nFires on the Plain,2014-01-01,Shin'ya Tsukamoto,5.80000019,Japanese\nFar from Men,2014-01-01,David Oelhoffen,7.5,english\nGood Kill,2014-01-01,Andrew Niccol,6.0999999,english\nLeopardi,2014-01-01,Mario Martone,6.9000001,english\nSivas,2014-01-01,Kaan M\u00fcjdeci,7.69999981,english\nBlack Souls,2014-01-01,Francesco Munzi,7.0999999,english\nThree Hearts,2014-01-01,Beno\u00eet Jacquot,5.80000019,French\nPasolini,2014-01-01,Abel Ferrara,5.80000019,english\nLe dernier coup de marteau,2014-01-01,Alix Delaporte,6.5,english\nManglehorn,2014-01-01,David Gordon Green,7.0999999,english\nHungry Hearts,2014-01-01,Saverio Costanzo,6.4000001,English\nBelye nochi pochtalona Alekseya Tryapitsyna,2014-01-01,Andrey Konchalovskiy,6.9000001,Russian\n99 Homes,2014-01-01,Ramin Bahrani,7.30000019,english\nThe Cut,2014-01-01,Fatih Akin,6,Armenian\nBirdman: Or (The Unexpected Virtue of Ignorance),2014-01-01,Alejandro Gonz\u00e1lez I\u00f1\u00e1rritu,8,English\nLa ran\u00e7on de la gloire,2014-01-01,Xavier Beauvois,5.69999981,French\nA Pigeon Sat on a Branch Reflecting on Existence,2014-01-01,Roy Andersson,7.19999981,english\nTales,2014-01-01,Rakhshan Bani-Etemad,6.80000019,english\nThe Wonders,2014-01-01,Alice Rohrwacher,6.80000019,Italian\nFoxcatcher,2014-01-01,Bennett Miller,7.19999981,English\nMr. Turner,2014-01-01,Mike Leigh,7,English\nJimmy's Hall,2014-01-01,Ken Loach,6.69999981,English\nThe Homesman,2014-01-01,Tommy Lee Jones,6.5999999,English\nThe Captive,2014-01-01,Atom Egoyan,5.9000001,english\nGoodbye to Language,2014-01-01,Jean-Luc Godard,6.19999981,French\nThe Search,2014-01-01,Michel Hazanavicius,6.9000001,French\nStill the Water,2014-01-01,Naomi Kawase,6.9000001,Japanese\nMommy,2014-01-01,Xavier Dolan,8.30000019,French\n\nTwo Days, One Night\n,2014-01-01,Jean-Pierre Dardenne,7.4000001,French\nMaps to the Stars,2014-01-01,David Cronenberg,6.4000001,English\nSaint Laurent,2014-01-01,Bertrand Bonello,6.5,French\nClouds of Sils Maria,2014-01-01,Olivier Assayas,6.9000001,english\nWinter Sleep,2014-01-01,Nuri Bilge Ceylan,8.5,Turkish\n\n\n\n\nFinally \n/film_nomination\n:\n\n\ncompetition,film,won\n1,1,f\n1,2,f\n1,3,f\n1,4,f\n1,5,f\n1,6,f\n1,7,f\n1,8,f\n1,9,f\n1,10,f\n1,11,f\n1,12,f\n1,13,f\n1,14,f\n1,15,f\n1,16,f\n1,17,f\n1,18,f\n1,19,f\n1,20,f\n2,21,f\n2,22,f\n2,23,f\n2,24,f\n2,25,f\n2,26,f\n2,27,f\n2,28,f\n2,29,f\n2,30,f\n2,31,f\n2,32,f\n2,33,f\n2,34,f\n2,35,f\n\n\n\n\nAt this point nominations are fully specified but it's not a convenient interface for a rest client. Let's make a view they can use. Paste this into \npsql demo1\n.\n\n\ncreate or replace view nomination as\nselect comp.festival,  \n       comp.name as competition,\n       comp.year,\n       film.title,\n       film.director,\n       film.rating\n from film_nomination as nom\n left join film on nom.film = film.id\n left join competition as comp on nom.competition = comp.id\n order by comp.year desc, comp.festival, competition;\n\n\n\n\nTime to try it out. Let's get the contents of the new view, ordered by film rating\n\n\nGET http://localhost:3000/nomination?order=rating.desc\n\n\n\n\nIf you find it more human readable, add an \nAccept: text/csv\n header.\n\n\nReleasing a New Version\n\n\nSuppose we want this endpoint to cater to those moviegoers with attention deficit disorder. In today's busy world we don't have time to read an extra couple words or compare nuanced reviews. In API version two we will truncate the names and round the ratings!\n\n\nEach version lives in a numbered schema, so let's make a schema for version two.\n\n\nCREATE SCHEMA \n2\n;\nGRANT USAGE ON SCHEMA \n2\n TO PUBLIC;\nALTER DATABASE demo1 SET search_path = \n2\n, \npublic\n;\n\n\n\n\nTo override the \nfilms\n endpoint create a view in the \"2\" schema with that name:\n\n\ncreate or replace view \n2\n.film as\nselect id, substring(f.title from 1 for 10) as title,\n       year, director, round(f.rating) as rating, language\nfrom \npublic\n.film as f;\n\n\n\n\nWe select the desired version as part of content negotiation. Try this get request:\n\n\nGET http://localhost:3000/film\nAccept: text/csv; version=2\n\n\n\n\nThen try toggling the version string in the Accept header and watch the results change. Pretty good, now how about writing values? PostgreSQL's nice feature called auto-updatable views allows writes to pass through views. Sadly this view is not eligible because truncation and rounding cannot be uniquely reversed. If we attempt to post a new result it complains:\n\n\n{\n  \nhint\n: null,\n  \ndetails\n: \nView columns that are not columns of their base relation are not updatable.\n,\n  \ncode\n: \n0A000\n,\n  \nmessage\n: \ncannot insert into column \\\ntitle\\\n of view \\\nfilm\\\n\n}\n\n\n\n\nThis is a case where we need explicit triggers\n\n\n-- TODO - FIX THIS\n\n-- CREATE OR REPLACE RULE insert_v2_films AS\n--   ON INSERT TO \n2\n.film\n--   DO INSTEAD\n--      INSERT INTO public.film (id, title, year, director, rating, language)\n--      VALUES (NEW.id,     NEW.title,\n--              NEW.year,   NEW.director,\n--              NEW.rating, NEW.language)\n--      RETURNING public.film.*;", 
            "title": "Getting Started"
        }, 
        {
            "location": "/examples/start/#getting-started", 
            "text": "Your First (simple) API  Let's start with the simplest thing possible. We will expose some tables directly for reading and writing by anyone.  Start by making a database  createdb demo1  We'll set it up with a film example (courtesy of  Jonathan Harrington ). Copy the following into your clipboard:  BEGIN;\n\nCREATE TABLE director\n(\n  name text NOT NULL PRIMARY KEY\n);\n\nCREATE TABLE film\n(\n  id serial PRIMARY KEY,\n  title text NOT NULL,\n  year date NOT NULL,\n  director text,\n  rating real NOT NULL DEFAULT 0,\n  language text NOT NULL,\n  CONSTRAINT film_director_fkey FOREIGN KEY (director)\n      REFERENCES director (name) MATCH SIMPLE\n      ON UPDATE CASCADE ON DELETE CASCADE\n);\n\nCREATE TABLE festival\n(\n  name text NOT NULL PRIMARY KEY\n);\n\nCREATE TABLE competition\n(\n  id serial PRIMARY KEY,\n  name text NOT NULL,\n  festival text NOT NULL,\n  year date NOT NULL,\n\n  CONSTRAINT comp_festival_fkey FOREIGN KEY (festival)\n      REFERENCES festival (name) MATCH SIMPLE\n      ON UPDATE CASCADE ON DELETE CASCADE\n);\n\nCREATE TABLE film_nomination\n(\n  id serial PRIMARY KEY,\n  competition integer NOT NULL,\n  film integer NOT NULL,\n  won boolean NOT NULL DEFAULT true,\n\n  CONSTRAINT nomination_competition_fkey FOREIGN KEY (competition)\n     REFERENCES competition (id) MATCH SIMPLE\n     ON UPDATE NO ACTION ON DELETE NO ACTION,\n  CONSTRAINT nomination_film_fkey FOREIGN KEY (film)\n     REFERENCES film (id) MATCH SIMPLE\n     ON UPDATE CASCADE ON DELETE CASCADE\n);\n\nCOMMIT;  Apply it to your new database by running  # On OS X\npbpaste | psql demo1\n\n# Or Linux\n# xclip -selection clipboard -o | psql demo1  Start the PostgREST server and point it at the new database.  postgrest -d demo1 -U postgres -a postgres --v1schema public  \n     Note about database users \n\n     If you installed PostgreSQL with Homebrew on Mac then the\n    database username may be your own login rather than\n     postgres .   Let's use PostgREST to populate the database. Install a REST client such as  Postman . Now let's insert some data as a bulk post in CSV format:  POST http://localhost:3000/festival\nContent-Type: text/csv\n\nname\nVenice Film Festival\nCannes Film Festival  In Postman it will look like this   Notice that the post type is  raw  and that  Content-Type: text/csv  set in the Headers tab.   Note that the server returns a multipart response with URL of each created resource.  Content-Type: application/json\nLocation: /festival?name=eq.Venice%20Film%20Festival\n\n\n--postgrest_boundary\nContent-Type: application/json\nLocation: /festival?name=eq.Cannes%20Film%20Festival  If you send a GET request to  /festival  it should return  [\n  {\n     name :  Venice Film Festival \n  },\n  {\n     name :  Cannes Film Festival \n  }\n]  Now that you've seen how to do a bulk insert, let's do some more and fully populate the database.  Post the following to  /competition :  name,festival,year\nGolden Lion,Venice Film Festival,2014-01-01\nPalme d'Or,Cannes Film Festival,2014-01-01  Now  /director :  name\nBertrand Bonello\nAtom Egoyan\nDavid Gordon Green\nAndrey Konchalovskiy\nMario Martone\nMike Leigh\nRoy Andersson\nSaverio Costanzo\nAlix Delaporte\nJean-Pierre Dardenne\nXiaoshuai Wang\nKaan M\u00fcjdeci\nTommy Lee Jones\nNuri Bilge Ceylan\nMichel Hazanavicius\nXavier Dolan\nRamin Bahrani\nAlice Rohrwacher\nAndrew Niccol\nRakhshan Bani-Etemad\nDavid Oelhoffen\nBennett Miller\nDavid Cronenberg\nShin'ya Tsukamoto\nJoshua Oppenheimer\nOlivier Assayas\nJean-Luc Godard\nAlejandro Gonz\u00e1lez I\u00f1\u00e1rritu\nBeno\u00eet Jacquot\nFatih Akin\nFrancesco Munzi\nKen Loach\nAbel Ferrara\nXavier Beauvois\nNaomi Kawase  And  /film :  title,year,director,rating,language\nChuang ru zhe,2014-01-01,Xiaoshuai Wang,6.19999981,english\nThe Look of Silence,2014-01-01,Joshua Oppenheimer,8.30000019,Indonesian\nFires on the Plain,2014-01-01,Shin'ya Tsukamoto,5.80000019,Japanese\nFar from Men,2014-01-01,David Oelhoffen,7.5,english\nGood Kill,2014-01-01,Andrew Niccol,6.0999999,english\nLeopardi,2014-01-01,Mario Martone,6.9000001,english\nSivas,2014-01-01,Kaan M\u00fcjdeci,7.69999981,english\nBlack Souls,2014-01-01,Francesco Munzi,7.0999999,english\nThree Hearts,2014-01-01,Beno\u00eet Jacquot,5.80000019,French\nPasolini,2014-01-01,Abel Ferrara,5.80000019,english\nLe dernier coup de marteau,2014-01-01,Alix Delaporte,6.5,english\nManglehorn,2014-01-01,David Gordon Green,7.0999999,english\nHungry Hearts,2014-01-01,Saverio Costanzo,6.4000001,English\nBelye nochi pochtalona Alekseya Tryapitsyna,2014-01-01,Andrey Konchalovskiy,6.9000001,Russian\n99 Homes,2014-01-01,Ramin Bahrani,7.30000019,english\nThe Cut,2014-01-01,Fatih Akin,6,Armenian\nBirdman: Or (The Unexpected Virtue of Ignorance),2014-01-01,Alejandro Gonz\u00e1lez I\u00f1\u00e1rritu,8,English\nLa ran\u00e7on de la gloire,2014-01-01,Xavier Beauvois,5.69999981,French\nA Pigeon Sat on a Branch Reflecting on Existence,2014-01-01,Roy Andersson,7.19999981,english\nTales,2014-01-01,Rakhshan Bani-Etemad,6.80000019,english\nThe Wonders,2014-01-01,Alice Rohrwacher,6.80000019,Italian\nFoxcatcher,2014-01-01,Bennett Miller,7.19999981,English\nMr. Turner,2014-01-01,Mike Leigh,7,English\nJimmy's Hall,2014-01-01,Ken Loach,6.69999981,English\nThe Homesman,2014-01-01,Tommy Lee Jones,6.5999999,English\nThe Captive,2014-01-01,Atom Egoyan,5.9000001,english\nGoodbye to Language,2014-01-01,Jean-Luc Godard,6.19999981,French\nThe Search,2014-01-01,Michel Hazanavicius,6.9000001,French\nStill the Water,2014-01-01,Naomi Kawase,6.9000001,Japanese\nMommy,2014-01-01,Xavier Dolan,8.30000019,French Two Days, One Night ,2014-01-01,Jean-Pierre Dardenne,7.4000001,French\nMaps to the Stars,2014-01-01,David Cronenberg,6.4000001,English\nSaint Laurent,2014-01-01,Bertrand Bonello,6.5,French\nClouds of Sils Maria,2014-01-01,Olivier Assayas,6.9000001,english\nWinter Sleep,2014-01-01,Nuri Bilge Ceylan,8.5,Turkish  Finally  /film_nomination :  competition,film,won\n1,1,f\n1,2,f\n1,3,f\n1,4,f\n1,5,f\n1,6,f\n1,7,f\n1,8,f\n1,9,f\n1,10,f\n1,11,f\n1,12,f\n1,13,f\n1,14,f\n1,15,f\n1,16,f\n1,17,f\n1,18,f\n1,19,f\n1,20,f\n2,21,f\n2,22,f\n2,23,f\n2,24,f\n2,25,f\n2,26,f\n2,27,f\n2,28,f\n2,29,f\n2,30,f\n2,31,f\n2,32,f\n2,33,f\n2,34,f\n2,35,f  At this point nominations are fully specified but it's not a convenient interface for a rest client. Let's make a view they can use. Paste this into  psql demo1 .  create or replace view nomination as\nselect comp.festival,  \n       comp.name as competition,\n       comp.year,\n       film.title,\n       film.director,\n       film.rating\n from film_nomination as nom\n left join film on nom.film = film.id\n left join competition as comp on nom.competition = comp.id\n order by comp.year desc, comp.festival, competition;  Time to try it out. Let's get the contents of the new view, ordered by film rating  GET http://localhost:3000/nomination?order=rating.desc  If you find it more human readable, add an  Accept: text/csv  header.  Releasing a New Version  Suppose we want this endpoint to cater to those moviegoers with attention deficit disorder. In today's busy world we don't have time to read an extra couple words or compare nuanced reviews. In API version two we will truncate the names and round the ratings!  Each version lives in a numbered schema, so let's make a schema for version two.  CREATE SCHEMA  2 ;\nGRANT USAGE ON SCHEMA  2  TO PUBLIC;\nALTER DATABASE demo1 SET search_path =  2 ,  public ;  To override the  films  endpoint create a view in the \"2\" schema with that name:  create or replace view  2 .film as\nselect id, substring(f.title from 1 for 10) as title,\n       year, director, round(f.rating) as rating, language\nfrom  public .film as f;  We select the desired version as part of content negotiation. Try this get request:  GET http://localhost:3000/film\nAccept: text/csv; version=2  Then try toggling the version string in the Accept header and watch the results change. Pretty good, now how about writing values? PostgreSQL's nice feature called auto-updatable views allows writes to pass through views. Sadly this view is not eligible because truncation and rounding cannot be uniquely reversed. If we attempt to post a new result it complains:  {\n   hint : null,\n   details :  View columns that are not columns of their base relation are not updatable. ,\n   code :  0A000 ,\n   message :  cannot insert into column \\ title\\  of view \\ film\\ \n}  This is a case where we need explicit triggers  -- TODO - FIX THIS\n\n-- CREATE OR REPLACE RULE insert_v2_films AS\n--   ON INSERT TO  2 .film\n--   DO INSTEAD\n--      INSERT INTO public.film (id, title, year, director, rating, language)\n--      VALUES (NEW.id,     NEW.title,\n--              NEW.year,   NEW.director,\n--              NEW.rating, NEW.language)\n--      RETURNING public.film.*;", 
            "title": "Getting Started"
        }
    ]
}